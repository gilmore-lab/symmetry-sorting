---
title: "Wallpaper sorting study data surgery"
author: "Rick Gilmore"
date: "`r Sys.time()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Purpose

This document describes the process involved in creating datasets for analysis of the symmetry sorting study data.
There are two types of data files.

One is at the wallpaper exemplar pair level.
For each wallpaper exemplar pair, this data file should have the Jaccard index, a link to the actual image(s) (e.g., on Databrary), and any pair-wise image similarity metrics available for the pair, such as SSID, dot product, etc.
The file also includes the wallpaper group associated with each exemplar pair.

The second data file is at the individual participant level.
This file includes any demographic information available about the participant(s), and for each wallpaper group, data about the number of categories the participants created, and the number of exemplars in the categories.



# Set-up

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(lme4)
```

## External resources

There is a Databrary volume at <https://nyu.databrary.org/volume/77>.

The project's GitHub repository is <https://github.com/gilmore-lab/symmetry-sorting>.

# Import

## Participant-level data

The first version imports data saved locally in `analysis/data/nsets.csv`.

```{r}
df_nsets <- readr::read_csv("analysis/data/nsets.csv")
```

Let's visualize these.

```{r}
df_nsets %>%
  ggplot(.) +
  aes(Nsets, fill = Group) +
  geom_dotplot(dotsize=1.5) +
  facet_grid(. ~ Group) +
  labs(x="Number of Sets", y="") +
  theme(axis.text.y = element_blank()) +
  scale_y_continuous(breaks=NULL) +
  guides( fill=FALSE )
```

We do not have participant-level demographic data on Databrary, so we will have to find those.

## Exemplar-pair data

The `make.symm.df()` function loads the sorting data from `analysis/data/xlsx`.
I modified it slightly to return the exemplar codes as column names.
Also added are two helper functions that save CSVs by wallpaper group: `save_sorting_csv()` and `save_all_sorting_csv()`.
This should make it easier to match the exemplar codes with their actual images when that time comes.

The function `make.jaccard.df()` takes a list of data.frames generated by `make.symm.df()` and then computes the Jaccard indices using `jaccard.data()`.
Let's test it with a single data file

```{r}
source("analysis/jaccard.data.R")
p1 <- readr::read_csv("analysis/data/P1-sorting.csv")
jaccard.data(p1)
```

That works, but I want the exemplar codes rather than indices.
I edited `jaccard.data()`, to replaces the image indices with their codes since these are available in the column names.

Now, we can make a data frame with all of the Jaccard values for all of the wallpaper groups.

```{r}
get_sorting_df <- function(wp) {
  fn <- list.files("analysis/data", paste0('^', wp, '\\-'), full.names = TRUE)
  readr::read_csv(fn)
}

all_sorting_list <- purrr::map(c("P1", "P31M", "P3M1", "P6", "P6M"), get_sorting_df)

j_all <- purrr::map_df(all_sorting_list, jaccard.data)
```

Let's save this as an intermediate result.

```{r}
readr::write_csv(j_all, "analysis/data/jaccard-no-duplicates.csv")
```

### Image metrics

The function `compute.image.metric()` relies on helper function `load.wp()` to load the images from Databrary.
It looks like the CSV that supports this was generated by hand.
I'm going to pull the names from Databrary directly to avoid any mishaps.
To do so, I'll write a function that given an exemplar code, the Databrary slot and asset values are returned.

```{r}
db_77 <- databraryapi::list_containers_records(vol_id = 77)
db_77$containers
```

Note that the `id` variable here--the "session" identifier (soon to be 'folder') on Databrary--has the name of the symmetry group.
We can us this to list the assets in a given session/folder.

```{r}
displays_df <- db_77$containers %>%
  dplyr::filter(., str_detect(name, 'displays'))

p1_s <- databraryapi::list_assets_in_session(displays_df$id[1])

make_databrary_image_df <- function(i, df = displays_df) {
  require(tidyverse)
  
  wp_group <- stringr::str_remove(df$name[i], 'displays-')
  out_df <- databraryapi::list_assets_in_session(df$id[i])
  out_df$group <- wp_group
  
  out_df <- out_df %>%
    dplyr::select(., group, session_id, asset_id, name) %>%
    dplyr::rename(., asset = asset_id, slot = session_id) %>%
    dplyr::arrange(., group, slot, asset) %>%
    dplyr::mutate(
      .,
      url = paste(
        'https://nyu.databrary.org/slot',
        slot,
        '-/asset',
        asset,
        'download?inline=true',
        sep = '/'
      )
    ) %>%
    dplyr::mutate(., img_index = 1:length(asset))
  out_df
}

displays_databrary_df <-
  purrr::map_df(1:5, make_databrary_image_df)
```

Rick loves functional programming.

Now, we have a data frame we can merge/join with any image metric data we want.
Let's save it and replace `wallpapers-on-databrary.csv`.

```{r}
readr::write_csv(displays_databrary_df, 'analysis/data/wallpapers-on-databrary.csv')
```

Now we can look at `compute.image.metric()` again.

I made some changes to the function to allow it to save the exemplar codes.
**TODO:(ROG)** grab the image metric from the function call and write it to the data frame.

In any event, now `compute.image.metric()` works as follows:

```{r}
head(compute.image.metric())
```
The default image metric is `ssid` so let's add that in a column, and save it appropriately.

```{r}
ssid <- purrr::map_df(c("P1", "P31M", "P3M1", "P6", "P6M"), compute.image.metric)
ssid$measure_type = 'ssid'

readr::write_csv(ssid, 'analysis/data/ssid.csv')
```

Now, we should be able to merge/join these.

```{r}
wp_merge <- dplyr::full_join(j_all, ssid, by = c('Exemplar.Row', 'Exemplar.Col', 'Group'))
```

We'll reimport the CSVs because of the type conflicts invoked by using data.frames and tibbles interchangeably.

```{r}
ssid <- readr::read_csv("analysis/data/ssid.csv")
jaccard <- read_csv("analysis/data/jaccard-no-duplicates.csv")

wp_merge <- dplyr::left_join(jaccard, ssid, by = c('Exemplar.Row', 'Exemplar.Col', 'Group'))
```

Let's do one last bit before we break.
Add in the image pixel-wise dot product.

```{r}
dot_prod <- purrr::map_df(c("P1", "P31M", "P3M1", "P6", "P6M"), compute.image.metric, FUN = image.dot.prod)
dot_prod$measure_type = 'dot_prod'

readr::write_csv(ssid, 'analysis/data/dot_prod.csv')
```

~~That works, but you forget that your `ssid` and `dot_prod` data sets were only for the one 'P1' group~~. 

I fixed that error.

Now, let's merge the dot product data.

```{r}
wp_merge_clean <- wp_merge %>%
  dplyr::select(., Exemplar.Row, 
  Exemplar.Col, Jaccard, Measure_Val, Group) %>%
  dplyr::rename(., Exemplar_1 = Exemplar.Row,
                Exemplar_2 = Exemplar.Col,
                SSID = Measure_Val)

dot_prod_clean <- dot_prod %>%
  dplyr::select(., Exemplar.Row, 
  Exemplar.Col, Measure_Val, Group) %>%
  dplyr::rename(., Exemplar_1 = Exemplar.Row,
                Exemplar_2 = Exemplar.Col,
                Dot_Prod = Measure_Val)
  
wp_merge_clean <- dplyr::left_join(wp_merge_clean, dot_prod_clean, by = c('Exemplar_1', 'Exemplar_2', 'Group')) %>%
  dplyr::select(., Group, Exemplar_1, Exemplar_2, Jaccard, SSID, Dot_Prod)
```

Now, let's add back in the Databrary URLs.

```{r}
databrary_clean <- displays_databrary_df %>%
  dplyr::rename(., Group = group) %>%
  dplyr::mutate(., Group = toupper(Group))
```


```{r}
lookup_databrary_for_exemplar <- function(ex) {
  databrary_clean$url[databrary_clean$name == ex]
}

wp_merge_clean_databrary <- wp_merge_clean %>%
  dplyr::mutate(
    .,
    Exemplar_1_URL = unlist(purrr::map(Exemplar_1, lookup_databrary_for_exemplar)),
    Exemplar_2_URL = unlist(purrr::map(Exemplar_2, lookup_databrary_for_exemplar))
    )

readr::write_csv(wp_merge_clean_databrary, "analysis/data/wallpapers-sorting-image.csv")
```

