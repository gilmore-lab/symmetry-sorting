---
title: "Jaccard bootstrapping analysis"
author: "Rick Gilmore"
date: "`r Sys.time()`"
output: 
  html_document:
    toc: yes
    toc_depth: 3
    toc_float: no
---


# Purpose

This document summarizes Rick Gilmore's analysis of the Jaccard index data.

The goal is to explore ways to generate an empirical "null" distribution of the Jaccard index data to compare it to the observed data.

# Set-up

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  fig.path = "img/",
  dev = c("png"),
  dpi = 300,
  fig.align = "center",
  fig.width = 7,
  fig.height = 7
)

library(tidyverse)
```

**Note**: I have set `eval=FALSE` for a series of chunks below that generate the permuted sorting and Jaccard index data. These take many minutes to run.

# Analysis plan

1. Start with each participant's raw sorting data within each wallpaper group.
2. Permute the *exemplars* each participant sorted into similar piles by randomizing the mapping between the actual exemplar and the permuted exemplar id.
  - For example, start with data in `/analysis/data/{P1,P31M,P3M1,P6,P6M}-sorting.csv` and create new CSVs with the permuted values.
  - As a practical matter, this can simply involve permuting the column data in these CSVs.
3. Recalculate the Jaccard indices using the `analysis/make.jaccard.df.R` function.
4. Do 1-3 `n` times, where `n` is large, probably 1,000.
5. Compare the mean Jaccard indices (by wallpaper group) from the permuted set to the values we observed empirically.

# Preliminary work

Let's build and test a permutation function for the raw sorting data.

Now, let's generate multiple permuted CSVs.

```{r generate_n_sorting_permutations}
generate_n_sorting_permutations <-
  function(wp_group = "P1",
           n_permutations = 5) {
    csv_in <- paste0("analysis/data/", wp_group, "-sorting.csv")
    if (!file.exists(csv_in)) {
      stop(paste0("`csv_in` not found: ", csv_in))
    }
    
    df_in <- readr::read_csv(csv_in)
    
    df_exemplars <- df_in[, -c(1, 2, 23, 24)]
    out_m <- as.matrix(df_exemplars)
    for (p in 1:n_permutations) {
      csv_out <-
        paste0(
          "analysis/data/permutation_analysis/sorting_csv/",
          wp_group,
          "-sorting-perm-",
          stringr::str_pad(p, 3, pad = 0), ".csv"
        )
      
      for (r in 1:dim(out_m)[1]) {
        new_i <- sample(1:20)
        out_m[r, 1:20] <- out_m[r, new_i]
      }
      
      array_out <-
        as.data.frame(cbind(df_in$Participant, df_in$Set, out_m, df_in$Set_size, df_in$Group))
      
      # Rename!
      names(array_out) <-
        c("Participant",
          "Set",
          names(df_exemplars),
          "Set_size",
          "Group")
      array_out
    
      readr::write_csv(array_out, csv_out)
    }
  }
```

Then we test it.

```{r}
generate_n_sorting_permutations()
```

Now, let's confirm that we can calculate Jaccard indices from these data.

```{r make_jaccard_csvs}
make_jaccard_csvs <- function(wallpaper_group = "P1",
                              duplicates = FALSE,
                              input_dir = 'analysis/data/permutation_analysis/sorting_csv/',
                              output_dir = 'analysis/data/permutation_analysis/jaccards/') {
  # Makes a data.frame from the raw sorting data
  
  # Load externals
  source("analysis/jaccard.data.R")
  source("analysis/jaccard.R")
  
  these_csvs <-
    list.files(input_dir, paste0("^", wallpaper_group, "\\-"), full.names = TRUE)
  purrr::map(these_csvs,
             calculate_save_jaccard_df,
             wallpaper_group,
             jaccard_dir = output_dir)
}

# Load a sorting permutation file, calculate the Jaccard indices, and (conditionally) save it to file.
calculate_save_jaccard_df <- function(this_csv,
                                      wallpaper_group,
                                      save_output = TRUE,
                                      jaccard_dir = "analysis/data/permutation_analysis/jaccards/",
                                      vb = FALSE) {
  
  this_fn <- basename(this_csv)
  this_perm_number <- stringr::str_extract(this_fn, "[0-9]{3}")
  out_fn <-
    paste0(jaccard_dir,
           wallpaper_group,
           "-jaccard-",
           this_perm_number,
           ".csv")
  
  this_df <- readr::read_csv(this_csv)
  
  # Calculate Jaccard
  jaccard_df <- jaccard.data(this_df)
  
  if (save_output) {
    if (vb) message(paste0('Saving ', out_fn))
    readr::write_csv(jaccard_df, out_fn)
  } else {
    jaccard_df
  }
}
```

```{r, eval=FALSE}
make_jaccard_csvs()
```

# Generate data

## P1

```{r, eval=FALSE}
generate_n_sorting_permutations("P1", n_permutations = 999)
```

```{r, eval=FALSE}
make_jaccard_csvs("P1")
```

## P31M

```{r, eval=FALSE}
generate_n_sorting_permutations("P31M", n_permutations = 999)
```

```{r, eval=FALSE}
make_jaccard_csvs("P31M")
```

## P3M1

```{r, eval=FALSE}
generate_n_sorting_permutations("P3M1", n_permutations = 999)
```

```{r, eval=FALSE}
make_jaccard_csvs("P3M1")
```

## P6

```{r, eval=FALSE}
generate_n_sorting_permutations("P6", n_permutations = 999)
```

```{r, eval=FALSE}
make_jaccard_csvs("P6")
```

## P6M

```{r, eval=FALSE}
generate_n_sorting_permutations("P6M", n_permutations = 999)
```

```{r, eval=FALSE}
make_jaccard_csvs("P6M")
```

# Analyze simulated results

## Create helper functions

```{r make_perm_jaccard_df}
make_perm_jaccard_df <- function(this_csv) {
  this_fn <- basename(this_csv)
  this_perm_number <- stringr::str_extract(this_fn, "[0-9]{3}")
  this_df <- readr::read_csv(this_csv)
  
  this_df <- this_df %>%
    dplyr::mutate(
      .,
      exemplar_pair = paste0(
        stringr::str_extract(Exemplar.Row, "[0-9]{3}$"),
        "-",
        stringr::str_extract(Exemplar.Col, "[0-9]{3}$")
        ),
        perm = this_perm_number
    )
  
  this_df
}
```

```{r make_aggregate_perm_jaccard_df}
make_aggregate_perm_jaccard_df <- function(wp_group = "P1",
                                           input_dir = "analysis/data/permutation_analysis/jaccards",
                                           save_csv = TRUE,
                                           output_dir = "analysis/data/permutation_analysis/aggregates",
                                           vb = TRUE) {
  these_csvs <-
    list.files(input_dir, paste0("^", wp_group, "\\-"), full.names = TRUE)
  df <- purrr::map_df(these_csvs, make_perm_jaccard_df)
  
  if (save_csv) {
    out_fn <- file.path(output_dir, paste0(wp_group, "-aggregate-perm-jaccard.csv"))
    if (vb) message(paste0("Saving ", out_fn))
    readr::write_csv(df, out_fn)
  } else {
    df
  }
}
```

## Empirical distributions of Jaccard indices by group and exemplar-pair

### P1

Import the data.

```{r make-P1-perm, eval=FALSE}
P1_perm_df <- make_aggregate_perm_jaccard_df("P1")
```

```{r open-P1-perm}
P1_perm_df <- readr::read_csv("analysis/data/permutation_analysis/aggregates/P1-aggregate-perm-jaccard.csv")
```

Visualize.

```{r p1-perm-jaccard-hist}
P1_perm_df %>%
  ggplot2::ggplot(.) +
  ggplot2::aes(x = Jaccard) +
  ggplot2::geom_histogram(bins = 50)
```

Generate summary stats by exemplar pair.

```{r}
P1_perm_stats_df <- P1_perm_df %>%
  dplyr::group_by(., Group, exemplar_pair) %>%
  dplyr::summarize(., jaccard_mean = mean(Jaccard),
                   jaccard_sd = sd(Jaccard))
```

### P31M

Import the data.

```{r make-P31M-perm, eval=FALSE}
P31M_perm_df <- make_aggregate_perm_jaccard_df("P31M")
```

```{r open-P31M-perm}
P31M_perm_df <- readr::read_csv("analysis/data/permutation_analysis/aggregates/P31M-aggregate-perm-jaccard.csv")
```

Visualize.

```{r p31m-perm-jaccard-hist}
P31M_perm_df %>%
  ggplot2::ggplot(.) +
  ggplot2::aes(x = Jaccard) +
  ggplot2::geom_histogram(bins = 50)
```

Generate summary stats by exemplar pair.

```{r}
P31M_perm_stats_df <- P31M_perm_df %>%
  dplyr::group_by(., Group, exemplar_pair) %>%
  dplyr::summarize(., jaccard_mean = mean(Jaccard),
                   jaccard_sd = sd(Jaccard))
```

### P3M1

Import the data.

```{r make-P3M1-perm, eval=FALSE}
P3M1_perm_df <- make_aggregate_perm_jaccard_df("P3M1")
```

```{r open-P3M1-perm}
P3M1_perm_df <- readr::read_csv("analysis/data/permutation_analysis/aggregates/P3M1-aggregate-perm-jaccard.csv")
```

Visualize.

```{r p3m1-perm-jaccard-hist}
P3M1_perm_df %>%
  ggplot2::ggplot(.) +
  ggplot2::aes(x = Jaccard) +
  ggplot2::geom_histogram(bins = 50)
```

Generate summary stats by exemplar pair.

```{r}
P3M1_perm_stats_df <- P3M1_perm_df %>%
  dplyr::group_by(., Group, exemplar_pair) %>%
  dplyr::summarize(., jaccard_mean = mean(Jaccard),
                   jaccard_sd = sd(Jaccard))
```

### P6

Import the data.

```{r make-P6-perm, eval=FALSE}
P6_perm_df <- make_aggregate_perm_jaccard_df("P6")
```

```{r open-P6-perm}
P6_perm_df <- readr::read_csv("analysis/data/permutation_analysis/aggregates/P6-aggregate-perm-jaccard.csv")
```

Visualize.

```{r p6-perm-jaccard-hist}
P6_perm_df %>%
  ggplot2::ggplot(.) +
  ggplot2::aes(x = Jaccard) +
  ggplot2::geom_histogram(bins = 50)
```

Generate summary stats by exemplar pair.

```{r}
P6_perm_stats_df <- P6_perm_df %>%
  dplyr::group_by(., Group, exemplar_pair) %>%
  dplyr::summarize(., jaccard_mean = mean(Jaccard),
                   jaccard_sd = sd(Jaccard))
```

### P6M

Import the data.

```{r make-P6M-perm, eval=FALSE}
P6M_perm_df <- make_aggregate_perm_jaccard_df("P6M")
```

```{r open-P6M-perm}
P6M_perm_df <- readr::read_csv("analysis/data/permutation_analysis/aggregates/P6M-aggregate-perm-jaccard.csv")
```

Visualize.

```{r p6m-perm-jaccard-hist}
P6M_perm_df %>%
  ggplot2::ggplot(.) +
  ggplot2::aes(x = Jaccard) +
  ggplot2::geom_histogram(bins = 50)
```

Generate summary stats by exemplar pair.

```{r}
P6M_perm_stats_df <- P6M_perm_df %>%
  dplyr::group_by(., Group, exemplar_pair) %>%
  dplyr::summarize(., jaccard_mean = mean(Jaccard),
                   jaccard_sd = sd(Jaccard))
```

### Aggregating across groups

```{r}
jaccard_perm_df <- rbind(P1_perm_df, P31M_perm_df, P3M1_perm_df, P6_perm_df, P6M_perm_df)
```

Visualization.

```{r agg-perm-jaccard-histogram}
jaccard_perm_df %>%
  ggplot(.) +
  aes(Jaccard, color = Group) +
  facet_grid(Group ~ .) +
  geom_boxplot(bins = 50)
```

```{r agg-perm-jaccard-boxplot}
jaccard_perm_df %>%
  ggplot(.) +
  aes(Jaccard, color = Group) +
  facet_grid(Group ~ .) +
  geom_boxplot(bins = 50)
```

```{r agg-perm-jaccard-violin}
jaccard_perm_df %>%
  ggplot(.) +
  aes(x = Group, y = Jaccard) +
  geom_violin()
```

These plots show that the mean differences in Jaccard indices are reflected in the participants' data are shown in the permuted data, too. This makes sense since the participants detected regularities and sorted the exemplars into different numbers of sets. In permuting the exemplar identifiers within participants, we keep some of this structure.

Let's try aggregating the by-exemplar statistics.

```{r}
jaccard_perm_stats_df <- rbind(P1_perm_stats_df, P31M_perm_stats_df, P3M1_perm_stats_df, P6_perm_stats_df, P6M_perm_stats_df)

# Sort by group, exemplar_pair
jaccard_perm_stats_df <- jaccard_perm_stats_df %>%
  dplyr::arrange(Group, exemplar_pair)
```

```{r agg-mean-jaccard-hist}
jaccard_perm_stats_df %>%
  ggplot(.) +
  aes(x = jaccard_mean, fill = Group) +
  geom_histogram() +
  facet_grid(Group ~ .) + 
  ggtitle("Mean exemplar-pair Jaccard indices for permuted data")
```

```{r agg-sd-jaccard-hist}
jaccard_perm_stats_df %>%
  ggplot(.) +
  aes(x = jaccard_sd, fill = Group) +
  geom_histogram() +
  facet_grid(Group ~ .) +
  ggtitle("Standard deviation of exemplar-pair Jaccard indices for permuted data")
```

## Compare observed Jaccard to empirical distribution

Load the observed data and clean it.

```{r}
jaccard_observed_df <-
  readr::read_csv("analysis/data/jaccard-no-duplicates.csv")

jaccard_observed_df <- jaccard_observed_df %>%
  dplyr::mutate(.,
                exemplar_pair = paste0(
                  stringr::str_extract(Exemplar.Row, "[0-9]{3}$"),
                  "-",
                  stringr::str_extract(Exemplar.Col, "[0-9]{3}$")
                )) %>%
  dplyr::arrange(., Group, exemplar_pair)
```

Now, merge the permuted data with the observed data.

```{r}
jaccard_merged_df <- dplyr::left_join(jaccard_perm_stats_df,
                                      jaccard_observed_df,
                                      by = c("Group", "exemplar_pair"))

# Rearrange columns for convenience
jaccard_merged_df <- jaccard_merged_df %>%
  dplyr::select(., Group, exemplar_pair, Jaccard, jaccard_mean, jaccard_sd, Exemplar.Row, Exemplar.Col)

# Rename variables for clarity
jaccard_merged_df <- jaccard_merged_df %>%
  dplyr::rename(., group = Group, jaccard_obs = Jaccard, 
                jaccard_emp_mean = jaccard_mean,
                jaccard_emp_sd = jaccard_sd,
                exemplar_row = Exemplar.Row,
                exemplar_col = Exemplar.Col)
```

Calculate empirical z as $z_{emp}=J_{obs}-\mu_{J}$ for each exemplar pair.

```{r}
jaccard_merged_df <- jaccard_merged_df %>%
  dplyr::mutate(., z_emp = (jaccard_obs-jaccard_emp_mean)/jaccard_emp_sd,
                p_z_emp = pnorm(z_emp, jaccard_emp_mean, jaccard_emp_sd, lower.tail = FALSE))
```

Plot a histogram of `z_emp`.

```{r jaccard-emp-z-hist}
jaccard_merged_df %>%
  ggplot(.) +
  aes(z_emp, fill = group) +
  geom_histogram() +
  facet_grid(group ~ .)
```

Curiously, P31M, P6, P6M and P3M1 have exemplar pairs whose observed Jaccard indices are substantially larger than the empirically derived reference (null) distribution even though the mean Jaccard indices for P1 are the largest.

Just for fun, let's print the exemplar pairs whose `z_emp` exceed `r qnorm(p = 1-.0001)`` ($p<.0001$).

```{r}
jaccard_merged_df %>%
  dplyr::filter(., z_emp > 4) %>%
  dplyr::arrange(., group, desc(jaccard_emp_mean)) %>%
  knitr::kable(.)
```

Plot a histogram of `p_z_emp` or the probability associated with the empirical z.

```{r jaccard-p-emp-z-hist}
jaccard_merged_df %>%
  ggplot(.) +
  aes(p_z_emp, fill = group) +
  geom_histogram() +
  facet_grid(group ~ .)
```

## Heatmap visualizations

Create function to extract data and convert to matrix.

```{r}
extract_exemplar_index <- function(e) {
  stringr::str_extract(e, '[0-9]{2}$')
}

extract_exemplar_emp_z_matrix <- function(wp_group = "P1", df = jaccard_merged_df) {
  this_df <- df %>%
    dplyr::filter(., group == wp_group)
  
  this_matrix <- matrix(nrow = 20, ncol = 20)
  
  for (r in 1:190) {
    this_matrix[as.numeric(extract_exemplar_index(this_df$exemplar_row[r])), 
                as.numeric(extract_exemplar_index(this_df$exemplar_col[r]))] <-
      this_df$z_emp[r]
  }
  
  this_matrix
}

wp_emp_mean <- function(wp_group = "P1", df = jaccard_merged_df) {
  this_df <- df %>%
    dplyr::filter(., group == wp_group)
  
  mean(this_df$jaccard_emp_mean)
}

wp_emp_sd <- function(wp_group = "P1", df = jaccard_merged_df) {
  this_df <- df %>%
    dplyr::filter(., group == wp_group)
  
  sd(this_df$jaccard_emp_mean)
}
```

Test the functions.

```{r}
wp_emp_mean()
wp_emp_sd()
extract_exemplar_emp_z_matrix()
```
Now, let's turn to the heatmap.

```{r def-myheatmap-function}
# Based on stats::heatmap(), but with different defaults for axis labels
my_heatmap <- function (x, Rowv = NULL, Colv = if (symm) "Rowv" else NULL, 
    distfun = dist, hclustfun = hclust, reorderfun = function(d, 
        w) reorder(d, w), add.expr, symm = FALSE, revC = identical(Colv, 
        "Rowv"), scale = c("row", "column", "none"), na.rm = TRUE, 
    margins = c(5, 5), ColSideColors, RowSideColors, cexRow = 0.2 + 
        1/log10(nr), cexCol = 0.2 + 1/log10(nc), labRow = NULL, 
    labCol = NULL, main = NULL, xlab = NULL, ylab = NULL, 
    xside = 2, yside = 3, # 1=bottom, 2=left, 3=top, 4=right
    keep.dendro = FALSE, 
    verbose = getOption("verbose"), ...) 
{
    scale <- if (symm && missing(scale)) 
        "none"
    else match.arg(scale)
    if (length(di <- dim(x)) != 2 || !is.numeric(x)) 
        stop("'x' must be a numeric matrix")
    nr <- di[1L]
    nc <- di[2L]
    if (nr <= 1 || nc <= 1) 
        stop("'x' must have at least 2 rows and 2 columns")
    if (!is.numeric(margins) || length(margins) != 2L) 
        stop("'margins' must be a numeric vector of length 2")
    doRdend <- !identical(Rowv, NA)
    doCdend <- !identical(Colv, NA)
    if (!doRdend && identical(Colv, "Rowv")) 
        doCdend <- FALSE
    if (is.null(Rowv)) 
        Rowv <- rowMeans(x, na.rm = na.rm)
    if (is.null(Colv)) 
        Colv <- colMeans(x, na.rm = na.rm)
    if (doRdend) {
        if (inherits(Rowv, "dendrogram")) 
            ddr <- Rowv
        else {
            hcr <- hclustfun(distfun(x))
            ddr <- as.dendrogram(hcr)
            if (!is.logical(Rowv) || Rowv) 
                ddr <- reorderfun(ddr, Rowv)
        }
        if (nr != length(rowInd <- order.dendrogram(ddr))) 
            stop("row dendrogram ordering gave index of wrong length")
    }
    else rowInd <- 1L:nr
    if (doCdend) {
        if (inherits(Colv, "dendrogram")) 
            ddc <- Colv
        else if (identical(Colv, "Rowv")) {
            if (nr != nc) 
                stop("Colv = \"Rowv\" but nrow(x) != ncol(x)")
            ddc <- ddr
        }
        else {
            hcc <- hclustfun(distfun(if (symm) 
                x
            else t(x)))
            ddc <- as.dendrogram(hcc)
            if (!is.logical(Colv) || Colv) 
                ddc <- reorderfun(ddc, Colv)
        }
        if (nc != length(colInd <- order.dendrogram(ddc))) 
            stop("column dendrogram ordering gave index of wrong length")
    }
    else colInd <- 1L:nc
    x <- x[rowInd, colInd]
    labRow <- labRow[rowInd] %||% rownames(x) %||% (1L:nr)[rowInd]
    labCol <- labCol[colInd] %||% colnames(x) %||% (1L:nc)[colInd]
    if (scale == "row") {
        x <- sweep(x, 1L, rowMeans(x, na.rm = na.rm), check.margin = FALSE)
        sx <- apply(x, 1L, sd, na.rm = na.rm)
        x <- sweep(x, 1L, sx, "/", check.margin = FALSE)
    }
    else if (scale == "column") {
        x <- sweep(x, 2L, colMeans(x, na.rm = na.rm), check.margin = FALSE)
        sx <- apply(x, 2L, sd, na.rm = na.rm)
        x <- sweep(x, 2L, sx, "/", check.margin = FALSE)
    }
    lmat <- rbind(c(NA, 3), 2:1)
    lwid <- c(if (doRdend) 1 else 0.05, 4)
    lhei <- c((if (doCdend) 1 else 0.05) + if (!is.null(main)) 0.2 else 0, 
        4)
    if (!missing(ColSideColors)) {
        if (!is.character(ColSideColors) || length(ColSideColors) != 
            nc) 
            stop("'ColSideColors' must be a character vector of length ncol(x)")
        lmat <- rbind(lmat[1, ] + 1, c(NA, 1), lmat[2, ] + 1)
        lhei <- c(lhei[1L], 0.2, lhei[2L])
    }
    if (!missing(RowSideColors)) {
        if (!is.character(RowSideColors) || length(RowSideColors) != 
            nr) 
            stop("'RowSideColors' must be a character vector of length nrow(x)")
        lmat <- cbind(lmat[, 1] + 1, c(rep(NA, nrow(lmat) - 1), 
            1), lmat[, 2] + 1)
        lwid <- c(lwid[1L], 0.2, lwid[2L])
    }
    lmat[is.na(lmat)] <- 0
    if (verbose) {
        cat("layout: widths = ", lwid, ", heights = ", lhei, 
            "; lmat=\n")
        print(lmat)
    }
    dev.hold()
    on.exit(dev.flush())
    op <- par(no.readonly = TRUE)
    on.exit(par(op), add = TRUE)
    layout(lmat, widths = lwid, heights = lhei, respect = TRUE)
    if (!missing(RowSideColors)) {
        par(mar = c(margins[1L], 0, 0, 0.5))
        image(rbind(if (revC) 
            nr:1L
        else 1L:nr), col = RowSideColors[rowInd], axes = FALSE)
    }
    if (!missing(ColSideColors)) {
        par(mar = c(0.5, 0, 0, margins[2L]))
        image(cbind(1L:nc), col = ColSideColors[colInd], axes = FALSE)
    }
    par(mar = c(margins[1L], 0, 0, margins[2L]))
    if (!symm || scale != "none") 
        x <- t(x)
    if (revC) {
        iy <- nr:1
        if (doRdend) 
            ddr <- rev(ddr)
        x <- x[, iy]
    }
    else iy <- 1L:nr
    image(1L:nc, 1L:nr, x, xlim = 0.5 + c(0, nc), ylim = 0.5 + 
        c(0, nr), axes = FALSE, xlab = "", ylab = "", ...)
    axis(xside, 1L:nc, labels = labCol, las = 2, line = -0.5, tick = 0, 
        cex.axis = cexCol)
    if (!is.null(xlab)) 
        mtext(xlab, side = xside, line = margins[1L] - 1.25)
    axis(yside, iy, labels = labRow, las = 2, line = -0.5, tick = 0, 
        cex.axis = cexRow)
    if (!is.null(ylab)) 
        mtext(ylab, side = yside, line = margins[2L] - 1.25)
    if (!missing(add.expr)) 
        eval.parent(substitute(add.expr))
    par(mar = c(margins[1L], 0, 0, 0))
    if (doRdend) 
        plot(ddr, horiz = TRUE, axes = FALSE, yaxs = "i", leaflab = "none")
    else frame()
    par(mar = c(0, 0, if (!is.null(main)) 1 else 0, margins[2L]))
    if (doCdend) 
        plot(ddc, axes = FALSE, xaxs = "i", leaflab = "none")
    else if (!is.null(main)) 
        frame()
    if (!is.null(main)) {
        par(xpd = NA)
        title(main, cex.main = 1.5 * op[["cex.main"]])
    }
    invisible(list(rowInd = rowInd, colInd = colInd, Rowv = if (keep.dendro && 
        doRdend) ddr, Colv = if (keep.dendro && doCdend) ddc))
}
```

Combine the above into a new plotting function.

```{r}
value_breaks <- c(0, .0001, .001, .01, .1, 1)
color_palate <- RColorBrewer::brewer.pal(length(value_breaks)-1, "Oranges")
rev_color_palate <- color_palate[length(color_palate):1]
value_colors <-
    colorRampPalette(color_palate)(length(rev_color_palate))
legend_text <- c("<.0001", "<.001", "<.01", ".1", ">.1")
```

```{r}
plot_heatmap_p <- function(wp_group = "P1",
                         df = jaccard_merged_df,
                         show_legend = TRUE) {
  # Select wp_group

  j_matrix <- extract_exemplar_emp_z_matrix(wp_group)
  
  my_heatmap(
    j_matrix,
    Rowv = NA,
    Colv = NA,
    symm = TRUE,
    margins = c(30,30),
    col = value_colors,
    breaks = value_breaks,
    cexRow = 3.0,
    cexCol = 3.0
    )
  
  if (show_legend) {
    legend(x = "bottomright",
           legend = legend_text,
           fill = value_colors)
  }
}
```

Test the heatmap plotting function.

```{r, P1-p-emp-jaccard}
plot_heatmap_p("P1")
```

```{r, P31M-p-emp-jaccard}
plot_heatmap_p("P31M")
```

```{r, P3M1-p-emp-jaccard}
plot_heatmap_p("P3M1")
```

```{r, P6-p-emp-jaccard}
plot_heatmap_p("P6")
```

```{r, P6M-p-emp-jaccard}
plot_heatmap_p("P6M")
```

Why these graphs are so different from those in `exemplar-jaccard-plots.Rmd` has me stumped. I'm especially confused about why the top and side margins don't seem to behave as expeted.

I'm going to try a different approach to summarizing these. Let's add a categorical variable to indicate $p$ value of the empirical z.

```{r}
jaccard_merged_df <- jaccard_merged_df %>%
  dplyr::mutate(.,
                p_z_cuts =
                  cut(
                    p_z_emp,
                    c(0, .0001, .001, .01, .1, 1),
                    labels = c("<.0001", "<.001", "<.01", "<.1", ">.1"),
                    include.lowest = TRUE
                  ))
```

```{r, p_emp_z_jaccard}
jaccard_merged_df %>%
  ggplot(.) +
  aes(p_z_cuts, fill = group) +
  geom_bar() +
  facet_grid(group ~ .)
```

Or in tabular form:

```{r}
xtabs(~ p_z_cuts + group, jaccard_merged_df)
```

